"""
ì „ìˆ˜ íƒìƒ‰ ìµœì í™” ì—”ì§„
Factory Mass Layout Algorithmì„ ê¸°ë°˜ìœ¼ë¡œ ëª¨ë“  ê°€ëŠ¥í•œ ì£¼ê³µì • ë°°ì¹˜ ì¡°í•©ì„ íƒìƒ‰í•©ë‹ˆë‹¤.
"""

import time
from typing import Dict, List, Any, Optional
from optimization.base_engine import OptimizationEngine


class ExhaustiveSearchOptimizer(OptimizationEngine):
    """ì „ìˆ˜ íƒìƒ‰ ê¸°ë°˜ ìµœì í™” ì—”ì§„"""
    
    def __init__(self, layout_generator, fitness_calculator, constraint_handler):
        """
        ì´ˆê¸°í™”
        
        Args:
            layout_generator: ë°°ì¹˜ ìƒì„±ê¸°
            fitness_calculator: ì í•©ë„ ê³„ì‚°ê¸°
            constraint_handler: ì œì•½ ì¡°ê±´ ì²˜ë¦¬ê¸°
        """
        super().__init__(layout_generator, fitness_calculator, constraint_handler)
        self.name = "ì „ìˆ˜ íƒìƒ‰ (Exhaustive Search)"
        self.evaluated_combinations = 0
        self.valid_combinations = 0
        
    def optimize(self, 
                main_processes: List[Dict[str, Any]], 
                sub_processes: List[Dict[str, Any]], 
                visualizer=None,
                max_solutions: int = 8,
                **kwargs) -> List[Dict[str, Any]]:
        """
        ì „ìˆ˜ íƒìƒ‰ ìµœì í™” ì‹¤í–‰
        
        Args:
            main_processes: ì£¼ê³µì • ëª©ë¡ (ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ìƒíƒœ)
            sub_processes: ë¶€ê³µì • ëª©ë¡
            visualizer: ì‹¤ì‹œê°„ ì‹œê°í™”ê¸° (ì„ íƒì‚¬í•­)
            max_solutions: ë°˜í™˜í•  ìµœëŒ€ ì†”ë£¨ì…˜ ìˆ˜
            **kwargs: ì¶”ê°€ íŒŒë¼ë¯¸í„°
        
        Returns:
            ìµœì í™”ëœ ì†”ë£¨ì…˜ ëª©ë¡ (ì í•©ë„ ìˆœìœ¼ë¡œ ì •ë ¬)
        """
        print(f"ğŸ” {self.name} ìµœì í™” ì‹œì‘")
        print(f"   ì£¼ê³µì •: {len(main_processes)}ê°œ")
        print(f"   ë¶€ê³µì •: {len(sub_processes)}ê°œ")
        
        start_time = time.time()
        self.best_solutions = []
        self.fitness_history = []
        self.evaluated_combinations = 0
        self.valid_combinations = 0
        
        # 1ë‹¨ê³„: ì£¼ê³µì • ë°°ì¹˜ ì¡°í•© ìƒì„±
        print("\n1ï¸âƒ£ ì£¼ê³µì • ë°°ì¹˜ ì¡°í•© ìƒì„± ì¤‘...")
        main_layout_combinations = self.layout_generator.generate_main_layout_combinations(main_processes)
        
        if not main_layout_combinations:
            print("âŒ ìœ íš¨í•œ ì£¼ê³µì • ë°°ì¹˜ ì¡°í•©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            return []
        
        total_combinations = len(main_layout_combinations)
        print(f"âœ… ì£¼ê³µì • ë°°ì¹˜ ì¡°í•©: {total_combinations}ê°œ")
        
        # 2ë‹¨ê³„: ê° ì£¼ê³µì • ë°°ì¹˜ì— ë¶€ê³µì • ì¶”ê°€ ë° í‰ê°€
        print(f"\n2ï¸âƒ£ ë¶€ê³µì • ë°°ì¹˜ ë° ì í•©ë„ í‰ê°€ ì¤‘...")
        
        update_interval = max(1, total_combinations // 20)  # 5% ê°„ê²©ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        
        for i, main_layout in enumerate(main_layout_combinations):
            self.evaluated_combinations += 1
            
            # ë¶€ê³µì • ì¶”ê°€
            complete_layout = self.layout_generator.place_sub_processes_optimally(
                main_layout, 
                sub_processes,
                self.fitness_calculator.adjacency_weights
            )
            
            # ì œì•½ ì¡°ê±´ ê²€ì‚¬
            if self.constraint_handler.is_valid(complete_layout):
                self.valid_combinations += 1
                
                # ì í•©ë„ ê³„ì‚°
                fitness = self.fitness_calculator.calculate_fitness(complete_layout)
                
                # ë°°ì¹˜ ì½”ë“œ ìƒì„±
                layout_code = self.layout_generator.generate_layout_code(complete_layout)
                
                # ì†”ë£¨ì…˜ ìƒì„±
                solution = {
                    'layout': complete_layout,
                    'fitness': fitness,
                    'code': layout_code,
                    'method': 'exhaustive_search',
                    'generation': i + 1,
                    'evaluation_time': time.time() - start_time
                }
                
                # ë² ìŠ¤íŠ¸ ì†”ë£¨ì…˜ ì—…ë°ì´íŠ¸
                self.update_best_solutions(solution, max_solutions * 2)  # ì—¬ìœ ìˆê²Œ ìˆ˜ì§‘
                self.fitness_history.append(fitness)
                
                # ì‹¤ì‹œê°„ ì‹œê°í™” ì—…ë°ì´íŠ¸
                if visualizer and i % update_interval == 0:
                    visualizer.update_progress(
                        current=i + 1,
                        total=total_combinations,
                        best_fitness=max(self.fitness_history) if self.fitness_history else 0,
                        current_layout=complete_layout
                    )
            
            # ì§„í–‰ë¥  ì¶œë ¥ (10% ê°„ê²©)
            if (i + 1) % max(1, total_combinations // 10) == 0:
                progress = ((i + 1) / total_combinations) * 100
                elapsed = time.time() - start_time
                print(f"   ì§„í–‰ë¥ : {progress:.0f}% ({i + 1}/{total_combinations}) "
                      f"- ìœ íš¨: {self.valid_combinations}ê°œ - ì†Œìš”ì‹œê°„: {elapsed:.1f}ì´ˆ")
        
        end_time = time.time()
        optimization_time = end_time - start_time
        
        # ê²°ê³¼ ì •ë¦¬
        final_solutions = sorted(self.best_solutions, key=lambda x: x['fitness'], reverse=True)[:max_solutions]
        
        print(f"\nâœ… {self.name} ìµœì í™” ì™„ë£Œ!")
        print(f"   ì´ ì†Œìš”ì‹œê°„: {optimization_time:.2f}ì´ˆ")
        print(f"   í‰ê°€ëœ ì¡°í•©: {self.evaluated_combinations}ê°œ")
        print(f"   ìœ íš¨í•œ ì¡°í•©: {self.valid_combinations}ê°œ ({self.valid_combinations/self.evaluated_combinations*100:.1f}%)")
        
        if final_solutions:
            best_fitness = final_solutions[0]['fitness']
            worst_fitness = final_solutions[-1]['fitness']
            print(f"   ìµœê³  ì í•©ë„: {best_fitness:.2f}")
            print(f"   ìµœì € ì í•©ë„: {worst_fitness:.2f}")
            print(f"   ë°˜í™˜ ì†”ë£¨ì…˜: {len(final_solutions)}ê°œ")
        
        return final_solutions
    
    def get_optimization_statistics(self) -> Dict[str, Any]:
        """ìµœì í™” í†µê³„ ì •ë³´ ë°˜í™˜"""
        
        stats = {
            'algorithm': self.name,
            'evaluated_combinations': self.evaluated_combinations,
            'valid_combinations': self.valid_combinations,
            'success_rate': self.valid_combinations / max(1, self.evaluated_combinations),
            'solutions_found': len(self.best_solutions),
            'fitness_statistics': {}
        }
        
        if self.fitness_history:
            stats['fitness_statistics'] = {
                'max': max(self.fitness_history),
                'min': min(self.fitness_history),
                'average': sum(self.fitness_history) / len(self.fitness_history),
                'count': len(self.fitness_history)
            }
        
        return stats
    
    def analyze_search_space(self, main_processes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """íƒìƒ‰ ê³µê°„ ë¶„ì„"""
        
        num_processes = len(main_processes)
        
        # íšŒì „ ì¡°í•© ìˆ˜ (ê° ê³µì •ë§ˆë‹¤ 0ë„/90ë„)
        rotation_combinations = 2 ** num_processes
        
        # ë°©í–¥ ì¡°í•© ìˆ˜ (ê³µì • ê°„ ì—°ê²° ë°©í–¥: bottom, right, top, left)
        direction_combinations = 4 ** max(0, num_processes - 1)
        
        # ì´ ì¡°í•© ìˆ˜
        total_combinations = rotation_combinations * direction_combinations
        
        # ì˜ˆìƒ ì‹¤í–‰ ì‹œê°„ (ì¡°í•©ë‹¹ í‰ê·  10ms ê°€ì •)
        estimated_time_seconds = total_combinations * 0.01
        
        analysis = {
            'process_count': num_processes,
            'rotation_combinations': rotation_combinations,
            'direction_combinations': direction_combinations,
            'total_combinations': total_combinations,
            'estimated_time_seconds': estimated_time_seconds,
            'estimated_time_formatted': self._format_time(estimated_time_seconds),
            'complexity_class': self._classify_complexity(total_combinations),
            'recommendations': self._get_complexity_recommendations(total_combinations)
        }
        
        return analysis
    
    def _format_time(self, seconds: float) -> str:
        """ì‹œê°„ì„ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ í¬ë§·"""
        
        if seconds < 60:
            return f"{seconds:.1f}ì´ˆ"
        elif seconds < 3600:
            minutes = seconds / 60
            return f"{minutes:.1f}ë¶„"
        elif seconds < 86400:
            hours = seconds / 3600
            return f"{hours:.1f}ì‹œê°„"
        else:
            days = seconds / 86400
            return f"{days:.1f}ì¼"
    
    def _classify_complexity(self, total_combinations: int) -> str:
        """ë³µì¡ë„ ë¶„ë¥˜"""
        
        if total_combinations <= 1000:
            return "ë§¤ìš° ë‚®ìŒ"
        elif total_combinations <= 10000:
            return "ë‚®ìŒ"
        elif total_combinations <= 100000:
            return "ë³´í†µ"
        elif total_combinations <= 1000000:
            return "ë†’ìŒ"
        else:
            return "ë§¤ìš° ë†’ìŒ"
    
    def _get_complexity_recommendations(self, total_combinations: int) -> List[str]:
        """ë³µì¡ë„ì— ë”°ë¥¸ ê¶Œì¥ì‚¬í•­"""
        
        recommendations = []
        
        if total_combinations <= 1000:
            recommendations.append("ì „ìˆ˜ íƒìƒ‰ì´ ë§¤ìš° ë¹ ë¥´ê²Œ ì™„ë£Œë©ë‹ˆë‹¤")
            recommendations.append("ìµœì ì˜ ê²°ê³¼ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤")
        
        elif total_combinations <= 10000:
            recommendations.append("ì „ìˆ˜ íƒìƒ‰ì´ ì ì ˆí•œ ì‹œê°„ ë‚´ì— ì™„ë£Œë©ë‹ˆë‹¤")
            recommendations.append("ê³ í’ˆì§ˆ ê²°ê³¼ë¥¼ ê¸°ëŒ€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤")
        
        elif total_combinations <= 100000:
            recommendations.append("ì „ìˆ˜ íƒìƒ‰ì— ë‹¤ì†Œ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤")
            recommendations.append("ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜ê³¼ ë³‘í–‰ ì‚¬ìš©ì„ ê³ ë ¤í•˜ì„¸ìš”")
        
        elif total_combinations <= 1000000:
            recommendations.append("ì „ìˆ˜ íƒìƒ‰ì— ìƒë‹¹í•œ ì‹œê°„ì´ í•„ìš”í•©ë‹ˆë‹¤")
            recommendations.append("ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì´ë‚˜ ì‹œë®¬ë ˆì´í‹°ë“œ ì–´ë‹ë§ ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤")
        
        else:
            recommendations.append("ì „ìˆ˜ íƒìƒ‰ì€ ë¹„ì‹¤ìš©ì ì…ë‹ˆë‹¤")
            recommendations.append("íœ´ë¦¬ìŠ¤í‹± ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©ì„ ê°•ë ¥íˆ ê¶Œì¥í•©ë‹ˆë‹¤")
            recommendations.append("ê³µì • ìˆ˜ë¥¼ ì¤„ì´ê±°ë‚˜ ì œì•½ ì¡°ê±´ì„ ë‹¨ìˆœí™”í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•˜ì„¸ìš”")
        
        return recommendations
    
    def print_search_analysis(self, main_processes: List[Dict[str, Any]]):
        """íƒìƒ‰ ê³µê°„ ë¶„ì„ ê²°ê³¼ ì¶œë ¥"""
        
        analysis = self.analyze_search_space(main_processes)
        
        print(f"\nğŸ“Š ì „ìˆ˜ íƒìƒ‰ ë³µì¡ë„ ë¶„ì„")
        print(f"=" * 50)
        print(f"ğŸ­ ê³µì • ìˆ˜: {analysis['process_count']}ê°œ")
        print(f"ğŸ”„ íšŒì „ ì¡°í•©: {analysis['rotation_combinations']:,}ê°œ")
        print(f"â¡ï¸  ë°©í–¥ ì¡°í•©: {analysis['direction_combinations']:,}ê°œ")
        print(f"ğŸ¯ ì´ ì¡°í•© ìˆ˜: {analysis['total_combinations']:,}ê°œ")
        print(f"â±ï¸  ì˜ˆìƒ ì‹œê°„: {analysis['estimated_time_formatted']}")
        print(f"ğŸ“ˆ ë³µì¡ë„: {analysis['complexity_class']}")
        
        print(f"\nğŸ’¡ ê¶Œì¥ì‚¬í•­:")
        for recommendation in analysis['recommendations']:
            print(f"   - {recommendation}")


if __name__ == "__main__":
    # í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    print("ğŸ§ª ExhaustiveSearchOptimizer í…ŒìŠ¤íŠ¸")
    
    from core.config_loader import ConfigLoader, create_sample_config
    from core.process_classifier import ProcessClassifier
    from core.layout_generator import SequenceLayoutGenerator
    from core.fitness_calculator import FitnessCalculator
    from core.constraint_handler import ConstraintHandler
    
    try:
        # ìƒ˜í”Œ ì„¤ì • ìƒì„± ë° ë¡œë“œ
        create_sample_config('test_exhaustive_config.json')
        loader = ConfigLoader('test_exhaustive_config.json')
        config = loader.load_config()
        
        # ëª¨ë“ˆë“¤ ì´ˆê¸°í™”
        classifier = ProcessClassifier(config)
        main_processes, sub_processes = classifier.classify_processes()
        
        layout_generator = SequenceLayoutGenerator(
            site_width=config['site_dimensions']['width'],
            site_height=config['site_dimensions']['height'],
            fixed_zones=loader.get_fixed_zones()
        )
        
        fitness_calculator = FitnessCalculator(
            adjacency_weights=config.get('adjacency_weights', {}),
            spaces=config['spaces'],
            fixed_zones=loader.get_fixed_zones(),
            site_width=config['site_dimensions']['width'],
            site_height=config['site_dimensions']['height']
        )
        
        constraint_handler = ConstraintHandler(
            site_width=config['site_dimensions']['width'],
            site_height=config['site_dimensions']['height'],
            fixed_zones=loader.get_fixed_zones(),
            hazard_factors=config.get('hazard_factors', {})
        )
        
        # ì „ìˆ˜ íƒìƒ‰ ìµœì í™”ê¸° ì´ˆê¸°í™” ë° í…ŒìŠ¤íŠ¸
        optimizer = ExhaustiveSearchOptimizer(
            layout_generator=layout_generator,
            fitness_calculator=fitness_calculator,
            constraint_handler=constraint_handler
        )
        
        # íƒìƒ‰ ê³µê°„ ë¶„ì„
        optimizer.print_search_analysis(main_processes)
        
        # ìµœì í™” ì‹¤í–‰ (ì‘ì€ ê·œëª¨ë¡œ í…ŒìŠ¤íŠ¸)
        print(f"\nğŸš€ ìµœì í™” í…ŒìŠ¤íŠ¸ ì‹¤í–‰")
        solutions = optimizer.optimize(
            main_processes=main_processes,
            sub_processes=sub_processes,
            max_solutions=5
        )
        
        if solutions:
            print(f"\nğŸ† ìµœì í™” ê²°ê³¼:")
            for i, solution in enumerate(solutions[:3], 1):  # ìƒìœ„ 3ê°œë§Œ ì¶œë ¥
                print(f"   {i}. ì í•©ë„: {solution['fitness']:.2f} | ì½”ë“œ: {solution['code']}")
        
        # í†µê³„ ì •ë³´
        stats = optimizer.get_optimization_statistics()
        print(f"\nğŸ“ˆ ìµœì í™” í†µê³„:")
        print(f"   ì„±ê³µë¥ : {stats['success_rate']:.1%}")
        print(f"   ì†”ë£¨ì…˜ ìˆ˜: {stats['solutions_found']}ê°œ")
        
        if stats['fitness_statistics']:
            fs = stats['fitness_statistics']
            print(f"   ì í•©ë„ ë²”ìœ„: {fs['min']:.1f} ~ {fs['max']:.1f} (í‰ê· : {fs['average']:.1f})")
        
        print("\nâœ… í…ŒìŠ¤íŠ¸ ì™„ë£Œ")
        
    except Exception as e:
        print(f"âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {str(e)}")
        import traceback
        traceback.print_exc()